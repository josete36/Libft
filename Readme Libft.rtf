{\rtf1\ansi\ansicpg1252\cocoartf2578
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;\red255\green255\blue255;\red163\green217\blue121;\red194\green229\blue166;
\red184\green111\blue179;\red19\green19\blue19;\red72\green139\blue206;\red194\green125\blue100;\red203\green203\blue202;
\red212\green213\blue153;\red142\green213\blue255;\red167\green197\blue151;\red252\green90\blue64;\red19\green19\blue19;
\red203\green203\blue202;\red204\green172\blue105;\red203\green203\blue202;\red0\green0\blue0;\red134\green205\blue77;
\red183\green111\blue179;\red0\green0\blue0;\red71\green137\blue205;\red194\green126\blue101;\red202\green202\blue202;
\red212\green213\blue154;\red141\green212\blue254;\red167\green197\blue151;\red205\green173\blue106;\red202\green202\blue202;
\red203\green203\blue202;\red253\green150\blue129;}
{\*\expandedcolortbl;;\cssrgb\c100000\c100000\c100000\c0;\cssrgb\c69337\c86836\c54718;\cssrgb\c80097\c91038\c70905;
\cssrgb\c77483\c52772\c75312;\cssrgb\c9821\c9821\c9821;\cssrgb\c34356\c61927\c84545;\cssrgb\c80765\c56762\c46655;\cssrgb\c83411\c83411\c83099;
\cssrgb\c86232\c86184\c66253;\cssrgb\c61729\c86919\c100000;\cssrgb\c71061\c80852\c65647;\cssrgb\c100000\c44604\c31621;\cssrgb\c9832\c9831\c9819;
\cssrgb\c83502\c83501\c83084;\cssrgb\c84135\c72677\c48439;\cssrgb\c83320\c83320\c83112;\cssrgb\c0\c1\c1;\cssrgb\c58755\c82661\c37297;
\cssrgb\c77331\c52624\c75301;\cssrgb\c0\c0\c0;\cssrgb\c33936\c61427\c84130;\cssrgb\c80778\c56830\c46925;\cssrgb\c83229\c83229\c83125;
\cssrgb\c86261\c86245\c66529;\cssrgb\c61361\c86489\c99746;\cssrgb\c71008\c80807\c65805;\cssrgb\c84255\c72854\c48827;\cssrgb\c83137\c83137\c83137;
\cssrgb\c83320\c83320\c83112;\cssrgb\c100000\c65897\c57758;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}
{\list\listtemplateid2\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid101\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid2}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}{\listoverride\listid2\listoverridecount0\ls2}}
\paperw11900\paperh16840\margl1440\margr1440\vieww19380\viewh13280\viewkind0
\pard\tx220\tx720\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\li720\fi-720\pardirnatural\partightenfactor0
\ls1\ilvl0
\f0\fs24 \cf0 \cb2 {\listtext	\cb3 \'95\cb4 	}\cb2 ft_strlcpy\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0
\cf0 \cb1 \
		- Funci\'f3n que devuelve el tama\'f1o de la cadena creada, que al final va a ser lo que mida SRC (L).\
		- Garantiza la terminaci\'f3n en NULL o \'91 \\0 \'92 para todas las cadenas SRC que no sean de tama\'f1o 0.\
		- Habra que medir la cadena.\
		- Ver si el destino es disto de NULL y que el numero de bytes a copiar sea distinto de 0.\
			- Si esto es as\'ed, iremos creando la nueva cadena en destino. Siempre y cuando el valor del contador i sea menor que el 			tama\'f1o de SRC (L) y el contador sea menor que el numero de bytes a copiar, reservando uno para garantizar que el final 			de la cadena sea \'91\\0\'92 o NULL.\
		- Si SRC no existe o es cero, debe de dar segmentation fault o sea hacer CRASH. Por lo tanto no se contempla que SRC deba existir.\

\f1 \cf5 \cb6 \expnd0\expndtw0\kerning0
#include\cf7  \cf8 "libft.h"\cf9 \
\pard\pardeftab720\sl360\partightenfactor0
\cf9 \
\cf7 size_t\cf9   \cf10 ft_strlcpy\cf9 (\cf7 char\cf9  *\cf11 dst\cf9 , \cf7 const\cf9  \cf7 char\cf9  *\cf11 src\cf9 , \cf7 size_t\cf9  \cf11 dstsize\cf9 )\
\{\
    \cf7 size_t\cf9   i;\
    \cf7 size_t\cf9   l;\
\
        l = \cf10 ft_strlen\cf9 (src);\
        \cf5 if\cf9  (dst != \cf7 NULL\cf9  && n != \cf12 0\cf9 ) \cf13 \cb14 // He tenido que poner NULL porque los test no me aceptan \'91\\0\'92\cf9 \cb6 \
        \{\
            \cf5 while\cf9  ((i < l) && i < dstsize - \cf12 1\cf9 )\
            \{\
                \cf11 dst\cf9 [i] = \cf11 src\cf15 [i];\
                \cf9 i++;\
            \}\
            \cf11 dst\cf9 [i] = \cf8 '\cf16 \\0\cf8 '\cf9 ;\
        \}\
        \cf5 return\cf9  (l);\
\}\cf17 \
\cf18 \cb2 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl360\partightenfactor0
\ls2\ilvl0\cf18 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\cb19 ft_strlcat\
\pard\tx566\pardeftab720\sl360\partightenfactor0
\cf18 \cb2 \
	- A\'f1ade la cadena SRC al final de DST. Se a\'f1adir\'e1 como m\'e1ximo DSTSIZE - 1 y el ultimo car\'e1cter ser\'e1 NULL a menos que DSTSIZE 	sea 0 o la cadena dst original sea m\'e1s larga que dstsize(Si esto es as\'ed tendremos error: bus error: 10)\
\pard\tx566\pardeftab720\sl360\partightenfactor0
\cf18 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720\sl360\partightenfactor0
\cf20 \cb21 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec20 #include\cf22 \strokec22  \cf23 \strokec23 "libft.h"\cf24 \strokec24 \
\
\cf22 \strokec22 size_t\cf24 \strokec24   \cf25 \strokec25 ft_strlcat\cf24 \strokec24 (\cf22 \strokec22 char\cf24 \strokec24  *\cf26 \strokec26 dst\cf24 \strokec24 , \cf22 \strokec22 const\cf24 \strokec24  \cf22 \strokec22 char\cf24 \strokec24  *\cf26 \strokec26 src\cf24 \strokec24 , \cf22 \strokec22 size_t\cf24 \strokec24  \cf26 \strokec26 dstsize\cf24 \strokec24 )\
\{\
    \cf22 \strokec22 size_t\cf24 \strokec24   i;\
    \cf22 \strokec22 size_t\cf24 \strokec24   ldst;\
    \cf22 \strokec22 size_t\cf24 \strokec24   lsrc;\
    \cf22 \strokec22 size_t\cf24 \strokec24   fvldst;\
\
    ldst = \cf25 \strokec25 ft_strlen\cf24 \strokec24 (dst);\
    lsrc = \cf25 \strokec25 ft_strlen\cf24 \strokec24 (src);\
    fvldst = ldst;\
    \cf20 \strokec20 if\cf24 \strokec24  (dstsize <= ldst || dstsize == \cf27 \strokec27 0\cf24 \strokec24 )\
        \cf20 \strokec20 return\cf24 \strokec24  (lsrc + dstsize);\
    \cf20 \strokec20 else\cf24 \strokec24 \
    i = \cf27 \strokec27 0\cf24 \strokec24 ;\
    \cf20 \strokec20 while\cf24 \strokec24  (\cf26 \strokec26 src\cf24 \strokec24 [i] != \cf23 \strokec23 '\cf28 \strokec28 \\0\cf23 \strokec23 '\cf24 \strokec24  && ldst < (dstsize - \cf27 \strokec27 1\cf24 \strokec24 ))\
    \{\
        \cf26 \strokec26 dst\cf24 \strokec24 [ldst++] = \cf26 \strokec26 src\cf24 \strokec24 [i++];\
    \}\
    \cf26 \strokec26 dst\cf24 \strokec24 [ldst] = \cf23 \strokec23 '\cf28 \strokec28 \\0\cf23 \strokec23 '\cf24 \strokec24 ;\
    \cf20 \strokec20 return\cf24 \strokec24  (fvldst + lsrc);\
\}\
\cf29 \cb1 \strokec29 \
	\cf21 \strokec30 - \strokec24 Medimos las dos cadenas. Creamos y asignamos una nueva variable \cb31 \strokec30 fvldst\cb1 \strokec24  (first value ldst)(le asignamos el tama\'f1o original de 	dst y conservamos para devolver) Hacemos esto porque luego el valor de dst ir\'e1 cambiando. \
	- Si el tama\'f1o bytes a concatenar (dstsize) es menor que la longitud original de la cadena, devolvemos el tama\'f1o de SRC + 		dstsize.\
	- si el tama\'f1o de bytes a concatenar es mayor que la cadena dst entonces adjuntamos los bytes de dstsize de SRC a DST y cerraremos con \'91\\0\'92. Devolviendo la suma ambas cadenas.\cf29 \strokec29 \
\pard\tx566\pardeftab720\sl360\partightenfactor0
\cf18 \cb2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 	\
}